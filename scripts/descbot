#!/usr/bin/perl
$version = '$Id$';
#
# descbot -- A Calvin bot to send character descriptions on request.
#            Copyright 1996 by Russ Allbery <rra@cs.stanford.edu>
#
# This program is free software; you can redistribute it and/or modify it
# under the same terms as Perl itself.
#
# The purpose of this bot is to send descriptions of characters and other
# objects (for supporting channeling on a Calvin server).  What this means
# in general is that it sends files and directory listings via @msg at
# users' request, and therefore could potentially be modified to do other
# interesting things.

############################################################################
# Site configuration
############################################################################

# Root of all descriptions.  Under this directory should be one directory
# for each different description type, along with a directory named default
# which will be checked if no description type is given in a request.
$root = '/ftp/pub/complex/descs';

# Local hostname (used when sending the owner of a file).
$localhost = 'eyrie.org';


############################################################################
# Modules and declarations
############################################################################

require 5.002;

use Calvin::Client;
use Calvin::Manager;
use Calvin::Parse;

use strict;
use vars qw(@help $localhost $root $version);


############################################################################
# Sending files and directorie contents and information
############################################################################

# Check a filename for security.  We want to ensure that all filenames are
# simple names, containing no slashes, and are not equal to . or .. (to
# ensure that all file accesses stay relative to $root).
sub check_file {
    my ($filename) = @_;
    not ($filename =~ m%/% or $filename =~ /^\.\.?$/);
}

# Send a file to a user.  We want to let Calvin or their client do the line
# wrapping for us, so read in the entire file, killing initial and final
# whitespace, join the lines together, and send the whole thing to the user.
# Note that the result will be truncated if it exceeds Calvin's buffer size
# of 1024 characters.
sub send_file {
    my ($client, $user, $file) = @_;
    my $desc = '';
    open (FILE, $file) or return undef;
    while (<FILE>) {
	next if /^\s*$/;
	s/^\s+//;
	s/\s+$//;
	if (/\.$/) { $_ .= ' ' }
	$desc .= $_ . ' ';
    }
    chop $desc;
    $client->msg ($user, $desc);
}

# Send a directory listing to a user, prefixed by a message.  We skip all
# files beginning with ., so dotfiles can be used to hide files from all
# listings sent by descbot.  We also require that all the files be regular
# files and be readable by descbot.  If the total length of the directory
# listing exceeds 1024 characters, we split it into separate messages.
sub send_directory {
    my ($client, $user, $message, $dir) = @_;
    opendir (DIR, $dir) or return undef;
    my @list = sort grep { ! /^\./ && -r "$dir/$_" } readdir DIR;
    closedir DIR;
    while (@list) {
	my $total = length $message;
	while (@list && (!$total || $total + length $list[0] < 1000)) {
	    $message .= (shift @list) . ' ';
	    $total = length $message;
	}
	chop $message;
	$client->msg ($user, $message);
	$message = '';
    }
    1;
}

# Send the owner of a given file (as "name <e-mail@address>").  Name is
# obtained via getpwuid().
sub send_owner {
    my ($client, $user, $file) = @_;
    my $uid = (stat $file)[4];
    my ($account, $name) = (getpwuid ($uid))[0,6];
    if (not defined $account) { return undef }
    $client->msg ($user, "$name <$account\@$localhost>");
}


############################################################################
# Basic commands
############################################################################

# Send a help message to a user.  Our help information is in the data
# section at the end of the script, after the list of sites to connect to.
# If this is the first time we've been called, we read it into a global
# variable named @help; otherwise, we just send the contents of that
# variable.
sub send_help {
    my ($client, $user) = @_;
    unless (@help) { @help = <DATA> }
    foreach (@help) { $client->msg ($user, $_) }
}

# Send a description to a user.  We take the name of the object or character
# and an optional type; if type isn't specified, we use "default".
sub send_desc {
    my ($client, $user, $char, $type) = @_;
    $type = 'default' unless $type;
    if (check_file ($char) && check_file ($type)) {
	if (send_file ($client, $user, "$root/$type/$char")) {
	    return 1;
	}
    }
    $client->msg ($user, "No description of type $type for $char");
}

# Send the list of descriptions of a certain type to a user.  If no type is
# specified, assume "default".
sub send_list {
    my ($client, $user, $type) = @_;
    $type = 'default' unless $type;
    if (check_file ($type)) {
	if (send_directory ($client, $user, "Available descriptions: ",
			    "$root/$type")) {
	    return 1;
	}
    }
    $client->msg ($user, "Unknown type $type");
}

# Send the name and address of the player of a given character.  If no type
# is specified, assume "default".
sub send_player {
    my ($client, $user, $char, $type) = @_;
    $type = 'default' unless $type;
    if (check_file ($char) && check_file ($type)) {
	if (send_owner ($client, $user, "$root/$type/$char")) {
	    return 1;
	}
    }
    $client->msg ($user, "No description of type $type for $char");
}

# Send the list of valid description types.
sub send_types {
    my ($client, $user) = @_;
    send_directory ($client, $user, "Available description types: ", $root);
}


############################################################################
# Command parsing
############################################################################

# Parse a command string.  We want to break on white-space, support double
# quotes, support escaping of double quotes with backslashes, support
# escaping of backslashes, and lowercase anything not in double quotes.  We
# can't use Text::ParseWords because it's too smart for its own good.
sub parse {
    my ($line) = @_;
    my (@args, $done);
    do {
	if ($line =~ s/^\s*([^\"\s]+)($|\s+)//) {
	    push (@args, lc $1);
	} elsif ($line =~ s/^\s*\"(([^\"\\]|\\.)+)\"($|\s+)//) {
	    push (@args, $1);
	} else {
	    $done = 1;
	}
    } until ($done);
    return @args;
}


############################################################################
# Main routine
############################################################################

# We actually want to run as a daemon, so fork ourselves, exit the parent,
# and close the standard file handles.
#fork && exit;
#close STDIN;
#close STDOUT;
#close STDERR;

# Initialize the manager and create and connect the clients.  Connections
# should be specified at the end of the script, one per line, in the form
# "<host> <port> <nick>" and terminated by a blank line.
my $manager = new Calvin::Manager;
while (<DATA>) {
    last if /^\s*$/;
    my $client = new Calvin::Client;
    $client->connect (split);
    $manager->register ($client);
}

# Loop forever, since the bot should never exit except through manual
# intervention, and process commands.
while (1) {
    my $client = $manager->select;
    next if not defined $client;

    # Read in and parse the command.  We parse like the shell, essentially,
    # so multiword arguments should be put in quotes.  Arguments are
    # automatically lowercased unless in quotes.
    my ($code, $user, $message) = $client->read;
    next unless ($code == C_WHIS);
    next if ($message =~ /^- /);
    $message =~ s/\s+$//;
    my ($command, @args) = parse ($message);

    # Hand off to the appropriate sub based on the command.
    if    ($command =~ /^!?help$/) { send_help ($client, $user)          }
    elsif ($command eq '!list')    { send_list ($client, $user, @args)   }
    elsif ($command eq '!player')  { send_player ($client, $user, @args) }
    elsif ($command eq '!types')   { send_types ($client, $user)         }
    else                   { send_desc ($client, $user, $command, @args) }
}


############################################################################
# Connection and help data
############################################################################

__END__
mork.cs.columbia.edu 9090 desc
eyrie.org            9090 desc

Syntax:  <command> <arguments>  OR  <character> [<type>]
Valid commands:  !list <type>, !types, !player <character> [<type>]
