#!/usr/bin/perl -w
$version = '$Id$';
#
# descbot -- A Calvin bot to send character descriptions on request.
#            Copyright 1996 by Russ Allbery <rra@cs.stanford.edu>
#
# This program is free software; you can redistribute it and/or modify it
# under the same terms as Perl itself.

require 5.002;
use Calvin::Client;
use Calvin::Manager;
use Calvin::Parse;
use strict;
use vars qw($root $version);

# Root of all descriptions (change for different systems).
$root = '/ftp/pub/complex/descs';

{
    # Initialize the manager and create and connect the clients.
    my $manager = new Calvin::Manager;
    while (<DATA>) {
	my $client = new Calvin::Client;
	$client->connect (split);
	$manager->register ($client);
    }

    # Loop forever, since the bot should never exit except through manual
    # intervention, and process commands.
    while (1) {
	my $client = $manager->select;
	next if not defined $client;

	# Read in and parse the command.
	my ($code, $user, $message) = $client->read;
	next unless ($code == C_WHIS);
	next if ($message =~ /^- /);

	# Figure out what to do based on the command.
	if ($message =~ /^help($|\s)/i) {
	    &send_help ($client, $user);
	} elsif ($message =~ /^types($|\s)/i) {
	    &send_types ($client, $user, $root);
	} elsif ($message =~ /^list(?:\s+(\S+))?/i) {
	    my $type;
	    ($type = lc $1) =~ tr%/%%d if $1;
	    $type = 'default' unless $type;
	    if ($type !~ /^\./ && -r "$root/$type" && -d _) {
		&send_list ($client, $user, "$root/$type");
	    } else {
		$client->msg ($user, "Unknown type $type");
	    }
	} elsif ($message =~ /^player\s+(\S+)(?:\s+(\S+))?/i) {
	    my ($char, $type) = ($1, $2);
	    ($type = lc $2) =~ tr%/%%d if $2;
	    $type = 'default' unless $type;
	    if (-r "$root/$type/$char" && -f _) {
		&send_author ($client, $user, "$root/$type/$char");
	    } else {
		$client->msg ($user, "Unknown character $char");
	    }
	} else {
	    my ($char, $type) = ($message =~ /^\s*(\S+)(?:\s+(\S+))?/);
	    $type = 'default' unless $type;
	    ($type = lc $type) =~ tr%/%%d;
	    ($char = lc $char) =~ tr%/%%d;
	    if (-r "$root/$type/$char" && -f _) {
		&send_file ($client, $user, "$root/$type/$char");
	    } else {
		$client->msg ($user, "Unknown character $char");
	    }
	}
    }
}


# Send a description file.
sub send_file {
    my ($client, $user, $file) = @_;
    my $desc = '';

    open (DESC, $file) or return undef;
    while (<DESC>) {
	next if /^\s*$/;
	chomp;
	if (/\.$/) { $_ .= ' ' }
	$desc .= $_ . ' ';
    }
    chop $desc;
    $client->msg ($user, $desc);
}

# Send the name of the author of a character.
sub send_author {
    my ($client, $user, $file) = @_;
    my $uid = (stat $file)[4];
    my ($account, $name) = (getpwuid ($uid))[0,6];

    if ($account) {
	$client->msg ($user, "$name <$account\@eyrie.org>");
    } else {
	$client->msg ($user, "Invalid owner: $uid $account");
    }
}

# Send a directory listing of characters.
sub send_list {
    my ($client, $user, $dir) = @_;

    opendir (DIR, $dir) or return undef;
    my @chars = sort grep { ! /^\./ && -f "$dir/$_" && -r _ } readdir(DIR);
    $client->msg ($user, "There are descriptions for:  @chars");
    closedir DIR;
}

# Send a list of all types to the user.
sub send_types {
    my ($client, $user, $root) = @_;

    opendir (DIR, $root) or return undef;
    my @types = sort grep { ! /^\./ && -d "$root/$_" && -r _ } readdir(DIR);
    $client->msg ($user, "Description types:  @types");
    closedir DIR;
}

# Send help.
sub send_help {
    my ($client, $user) = @_;
    $client->msg ($user, "Syntax:  <command>  OR  <character> <type>");
    $client->msg ($user, "Valid commands:  help, list <type>, types");
}
__END__
mork.cs.columbia.edu 9090 desc
eyrie.org            9090 desc
